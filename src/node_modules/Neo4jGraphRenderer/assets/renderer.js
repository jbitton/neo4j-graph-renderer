import * as d3 from 'd3';
import neo from './util';

const graphRenderer = () => {

  const styleContents =
    `node {
      diameter: 40px;
      color: #DFE1E3;
      border-color: #D4D6D7;
      border-width: 2px;
      text-color-internal: #000000;
      text-color-external: #000000;
      caption: '{name}';
      font-size: 12px;
    }
    relationship {
      color: #4356C0;
      shaft-width: 3px;
      font-size: 9px;
      padding: 3px;
      text-color-external: #000000;
      text-color-internal: #FFFFFF;
    }\n`;

  const skip = ["id", "start", "end", "source", "target", "labels", "type", "selected", "properties"];
  const entities = ["name", "title", "tag", "username", "lastname", "caption"];

  const existingStyles = {};
  let currentColor = 1;

  const render = (id, $container, visualization) => {
    const extractProps = pc => {
      const p = {};
      for (let key in pc) {
        if (!pc.hasOwnProperty(key) || skip.indexOf(key) !== -1) continue;
        p[key] = pc[key];
      }
      return p;
    };

    const nodeStyles = nodes => {
      const label = n => {
        const labels = n["labels"];
        if (labels && labels.length) {
          return labels[labels.length - 1];
        }
        return "";
      };

      const style = {};
      for (let i = 0; i < nodes.length; i++) {
        const props = nodes[i].properties = extractProps(nodes[i]);
        const keys = Object.keys(props);
        if (label(nodes[i]) !== "" && keys.length > 0) {
          let selectedKeys = entities.filter(k => keys.indexOf(k) !== -1);
          selectedKeys = selectedKeys.concat(keys).concat(['id']);
          const selector = `node.${label(nodes[i])}`;
          const selectedKey = selectedKeys[0];
          if (typeof(props[selectedKey]) === "string" && props[selectedKey].length > 30) {
            props[selectedKey] = `${props[selectedKey].substring(0,30)} ...`;
          }
          style[selector] = style[selector] || selectedKey;
        }
      }
      return style;
    };

    const styleSheet = (styles, styleContents) => {
      const format = key => {
        const item = styles[key];
        return item.selector +
          " {caption: '{" + item.caption +
          "}'; color: " + item.color +
          "; border-color: " + item['border-color'] +
          "; text-color-internal: " +  item['text-color-internal'] +
          "; text-color-external: " +  item['text-color-external'] +
          "; }"
      };
      return styleContents + Object.keys(styles).map(format).join("\n");
    };

    const createStyles = (styleCaptions, styles) => {
      const { colors } = neo.style.defaults;
      for (let selector in styleCaptions) {
        if (!(selector in styles)) {
          const color = colors[currentColor];
          currentColor = (currentColor + 1) % colors.length;
          const textColor = window.isInternetExplorer ? '#000000' : color['text-color-internal'];
          const style = {selector:selector, caption:styleCaptions[selector], color:color.color,
            "border-color":color['border-color'], "text-color-internal":textColor,"text-color-external": textColor };
          styles[selector] = style;
        }
      }
      return styles;
    };

    const applyZoom = () => {
      renderer.select(".nodes").attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
      renderer.select(".relationships").attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    };

    const disableZoomHandlers = () => {
      renderer.on("wheel.zoom",null);
      renderer.on("mousewheel.zoom",null);
      renderer.on("mousedown.zoom", null);
      renderer.on("DOMMouseScroll.zoom", null);
      renderer.on("touchstart.zoom",null);
      renderer.on("touchmove.zoom",null);
      renderer.on("touchend.zoom",null);
    };

    const legend = (svg, styles) => {
      const keys = Object.keys(styles).sort();
      const circles = svg.selectAll('circle.legend').data(keys);
      const r = 20;

      circles.enter().append('circle').classed('legend', true).attr({ cx: 2 * r, r : r });

      circles.attr({
        cy: node => (keys.indexOf(node)+1) * 2.2 * r,
        fill: node => styles[node]['color'],
        stroke: node => styles[node]['border-color'],
        'stroke-width': node => "2px"
      });

      const text = svg.selectAll('text.legend').data(keys);
      text.enter().append('text').classed('legend',true).attr({
        'text-anchor': 'left',
        'font-weight': 'bold',
        'stroke-width': '0',
        'stroke-color': 'black',
        'fill': 'black',
        'x': 3.2 * r,
        'font-size' : "12px"
      });

      text.text(node => {
        const label = styles[node].selector;
        return label ? label.substring(5) : "";
      }).attr('y', node => (keys.indexOf(node)+1) * 2.2 * r + 6);

      return circles.exit().remove();
    };

    const { links, nodes } = visualization;
    for (let i = 0; i < links.length; i++) {
      links[i].source = links[i].start;
      links[i].target = links[i].end;
    }

    createStyles(nodeStyles(nodes), existingStyles);

    const graphModel = neo.graphModel()
      .nodes(nodes)
      .relationships(links);

    const graphView = neo.graphView()
      .style(styleSheet(existingStyles, styleContents))
      .width($container.width()).height($container.height());

    const svg = d3.select(`#${id}`).append("svg");
    const renderer = svg.data([graphModel]);
    legend(svg, existingStyles);
    const zoomHandlers = {};
    const zoomBehavior = d3.behavior.zoom().on("zoom", applyZoom).scaleExtent([0.2, 8]);

    renderer.call(graphView);
    renderer.call(zoomBehavior);

    zoomHandlers.wheel = renderer.on("wheel.zoom");
    zoomHandlers.mousewheel = renderer.on("mousewheel.zoom");
    zoomHandlers.mousedown = renderer.on("mousedown.zoom");
    zoomHandlers.DOMMouseScroll = renderer.on("DOMMouseScroll.zoom");
    zoomHandlers.touchstart = renderer.on("touchstart.zoom");
    zoomHandlers.touchmove = renderer.on("touchmove.zoom");
    zoomHandlers.touchend = renderer.on("touchend.zoom");
    disableZoomHandlers();

    const refresh = () => {
      graphView.height($container.height());
      graphView.width($container.width());
      renderer.call(graphView);
    };

    return  {
      'subscriptions': {
        'expand': refresh,
        'contract': refresh,
        'sizeChange': refresh
      }
    };
  };

  return {'render': render };
};

export { graphRenderer };